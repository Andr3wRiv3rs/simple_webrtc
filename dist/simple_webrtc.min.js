export const debug={name:{string:"[Simple WebRTC]",style:{color:"#ff69b4","font-weight":"600"}},message:{style:{color:"#fff"}}};
import{debug}from"../config.js";// adds default styles to messages before logging
const parseMessage=(a,b,c,d,e="")=>{for(const f of Object.keys(debug.name.style))e+=`${f}: ${debug.name.style[f]}; `;console[a](`%c${debug.name.string} %c${b}`,e,c||"",d||"")};export default new class{log(a){parseMessage("log",a)}error(a){parseMessage("error",a)}dir(a){parseMessage("dir",a)}warn(a){parseMessage("warn",a)}// special styles to indicate a specific method being used
code(a,b){parseMessage("error",`${a}${("object"==typeof b?"":"%c","")}`,"padding: 3px 7px; background-color: rgb(40,40,40); color: white;",b)}table(a){parseMessage("table",a)}};
function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}import Debug from"./debug.js";export default class{constructor(){_defineProperty(this,"events",{})}// adds function to the designated event
get on(){const{events:a}=this;return function(b,c=()=>{}){return"string"!=typeof b&&Debug.error(`Must provide an event string.`),a[b]=a[b]||[],"function"!=typeof c&&Debug.error(`Callback isn't a function,`),new Promise(d=>a[b].push(function(){c(...arguments),d(...arguments)}))}}// iterates on event's functions defined with `on`
// spreads all arguments except `event` into the function's parameters
get emit(){const{events:a}=this;return function(b){if("string"!=typeof b&&Debug.error(`Must provide an event string.`),!a[b])return!1;for(const c of a[b])c(...Array.from(arguments).splice(1,arguments.length))}}}
function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}import Emitter from"../util/emitter.js";import WebRTC from"./webrtc.js";import UserMedia from"./usermedia.js";import Debug from"../util/debug.js";export default class extends Emitter{constructor(a){// assign user options to default config
super(),_defineProperty(this,"peers",{}),_defineProperty(this,"config",{log:!1,debug:!1,peer:{json:!0}}),_defineProperty(this,"Peer",a=>this.peers[a]=new WebRTC(this)),Object.assign(this.config,a),this.config.debug&&(this.on("error",(a,b)=>{b?Debug.code(a,b):Debug.error(a)}),this.config.log&&this.on("log",a=>{Debug.log(a)}))}get Broadcast(){const{peers:a}=this;return b=>{for(const c of Object.values(a))c.send(b)}}// getter forwards emitter to UserMedia
get Media(){return new UserMedia(this)}}
function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}export default class extends RTCPeerConnection{constructor(a,{emit:b,on:c}){// once this event is emitted, the offer/answer methods will resolve
// this allows offers/answers to be transceived in one string (per peer)
// receiving event for added media tracks
super(),_defineProperty(this,"candidates",[]),_defineProperty(this,"datachannels",[]),Object.assign(this,{config:a,emit:b,on:c}),this.addEventListener("datachannel",a=>{// invoked when a connection has been established
// at this point it is safe to communicate
// the receiving event for the `DataChannel.send` method
a.channel.onopen=()=>{this.emit("open"),this.emit("log","datachannel open")},a.channel.onmessage=async a=>{try{const c=JSON.parse(a.data);if(c.renegotiation){if(this.emit("log","renegotiation"),this.SetRemoteDescription(c.sdp),"offer"===c.type){b("log","sending renegotiation answer");const a=await this.createAnswer();await this.SetLocalDescription(a),this.datachannels[0].send(JSON.stringify({type:"answer",renegotiation:!0,sdp:this.localDescription}),!1)}else b("log","received renegotiation answer");return}if("icecandidate"===c.type)return this.emit("log","received ice candidate"),this.AddIceCandidate(c.candidate)}catch{}this.emit("message",this.config.json?JSON.parse(a.data):a.data)},a.channel.onerror=a=>this.emit("error","PeerConnection.DataChannel",a)}),this.addEventListener("error",a=>{this.emit("error","PeerConnection",a)}),this.addEventListener("icecandidate",a=>{a.candidate&&(this.emit("icecandidate",a.candidate),this.candidates.push(a.candidate),this.emit("log","found ice candidate"))}),this.addEventListener("icegatheringstatechange",a=>{"complete"===a.target.iceGatheringState&&(this.emit("icecomplete",a),this.emit("log","ice gathering complete"))}),this.ontrack=a=>{this.emit("track",a)},this.emit("log","created peer"),this.addEventListener("negotiationneeded",a=>{this.emit("negotiationneeded",a),this.emit("log","negotiation needed")}),this.on("addtrack",({track:a,streams:b})=>{this.AddTrack(a,...b)})}// invoked by the `answer` and `open` methods
// bulk/individually add ice candidates
AddIceCandidate(a){try{if(!a)throw"no candidate(s) provided";if(Array.isArray(a))for(const b of a)this.addIceCandidate(new RTCIceCandidate(b));else this.addIceCandidate(new RTCIceCandidate(a));this.emit("log","added ice candidate(s)")}catch(a){this.emit("error","PeerConnection.addIceCandidate","no candidate(s) provided")}}// add a media track (video, audio, canvas)
// it is also used by the UserMedia class
AddTrack(a,b=[]){try{if(!a)throw"no track provided";Array.isArray(b)||(b=[b]),this.addTrack(a,...b),this.emit("log","added track(s)")}catch(a){this.emit("error","PeerConnection.addTrack",a)}}// DataChannel creation, contains the `send` method
// automatically stringifies content unless configured otherwise
CreateDataChannel(){try{const a=this.createDataChannel("main",{reliable:!0}),b=async(b,c=void 0)=>{if(!b)throw"no data provided";a.send((void 0===c?this.config.json:c)?JSON.stringify(b):b)};return this.datachannels.push({DataChannel:a,send:b}),this.emit("log","created data channel"),{DataChannel:a,send:b}}catch(a){this.emit("error","PeerConnection.CreateDataChannel",a)}}// local/remote descriptions take an offer/answer object
async SetLocalDescription(a){return await this.setLocalDescription(new RTCSessionDescription(a)),void this.emit("log","set local description")}async SetRemoteDescription(a){return await this.setRemoteDescription(new RTCSessionDescription(a)),void this.emit("log","set remote description")}Broadcast(a){for(const{send:b}of this.datachannels)b(a)}}
export default class{constructor({emit:a,on:b}){Object.assign(this,{emit:a,on:b})}async GetMedia({video:a,audio:b,screen:c}={video:!1,audio:!1},d,e){try{const e=c?await navigator.mediaDevices.getDisplayMedia({audio:b,video:a}):await navigator.mediaDevices.getUserMedia({audio:b,video:a});for(const a of e.getTracks())this.emit("addtrack",{track:a,streams:[e]});if(await this.on("negotiationneeded"),this.emit("media-negotiation"),d)if("function"==typeof d)d(e);else throw"`allow` is not of type `function`";return e}catch(a){if(!a.name||0>["NotAllowedError","AbortError","NotFoundError","SecurityError"].indexOf(a.name))throw a;if(this.emit("error","media.GetMedia","unable to access requested media"),e)if("function"==typeof e)e();else throw"`block` is not of type `function`";return null}}async microphone(a,b){try{return await this.GetMedia({audio:!0},a,b)}catch(a){this.emit("error","media.microphone",a)}}async camera(a,b){try{return await this.GetMedia({video:!0},a,b)}catch(a){this.emit("error","media.camera",a)}}async screen(a,b){try{return await this.GetMedia({video:!0,audio:!0,screen:!0},a,b)}catch(a){this.emit("error","media.screen",a)}}async custom(a,b,c){try{return await this.GetMedia(a,b,c)}catch(a){this.emit("error","media.custom")}}}
function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}import PeerConnection from"./peerconnection.js";import Emitter from"../util/emitter.js";export default class extends Emitter{constructor({config:a,emit:b,on:c}){// create new PeerConnection
super(),_defineProperty(this,"peerConnection",void 0),_defineProperty(this,"dataChannel",void 0),_defineProperty(this,"icecomplete",!1),this.peerConnection=new PeerConnection(a.peer,this),this.peerConnection.CreateDataChannel(),this.datachannels=this.peerConnection.datachannels,this.on("offer",async a=>{this.send((await this.answer(a)),!1)}),this.on("icecomplete",()=>{this.icecomplete=!0}),c("media-negotiation",async()=>{this.renegotiate()}),c("addtrack",a=>this.emit("addtrack",a)),this.on("negotiationneeded",()=>b("negotiationneeded")),this.on("log",a=>{b("log",a)}),this.on("error",(a,c)=>{b("error",a,c)}),(async()=>{await this.on("open"),this.on("icecandidate",a=>{a&&this.send({candidate:a,type:"icecandidate"},!0)})})()}// create offer (starting point)
async offer(){try{return await new Promise((a,b)=>{this.peerConnection.createOffer(async b=>{this.peerConnection.SetLocalDescription(b),this.icecomplete||(await this.on("icecomplete")),a(JSON.stringify({offer:b,candidates:this.peerConnection.candidates,type:"offer"}))},a=>b(a))})}catch(a){this.emit("error","offer",a)}}// create answer with offer
async answer(a){try{if(!a)throw"no offer provided";"string"==typeof a&&(a=JSON.parse(a));const{offer:b,candidates:c}=a;return this.peerConnection.SetRemoteDescription(b),await new Promise((a,b)=>this.peerConnection.createAnswer(async b=>{this.peerConnection.SetLocalDescription(b),this.icecomplete||(await this.on("icecomplete")),a(JSON.stringify({answer:b,candidates:this.peerConnection.candidates,type:"answer"})),this.peerConnection.AddIceCandidate(c)},a=>b(a)))}catch(a){this.emit("error","answer",a)}}async renegotiate(){this.emit("log","renegotiating");const{offer:a}=JSON.parse((await this.offer()));await this.peerConnection.SetLocalDescription(a),this.send(JSON.stringify({type:"offer",renegotiation:!0,sdp:this.peerConnection.localDescription}),!1)}// establish connection with answer object
async open(a){try{if(!a)throw"no answer provided";"string"==typeof a&&(a=JSON.parse(a));const{answer:b,candidates:c}=a;return this.peerConnection.SetRemoteDescription(b),this.peerConnection.AddIceCandidate(c),void(await this.on("open"))}catch(a){this.emit("error","open",a)}}send(a,b,c=0){this.peerConnection.datachannels[c].send(a,b)}}
